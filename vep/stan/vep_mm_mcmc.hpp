
// Code generated by stanc v2.29.2
#include <stan/model/model_header.hpp>
namespace vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 303> locations_array__ = 
{" (found before start of program)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 102, column 2 to column 25)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 103, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 104, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 105, column 2 to column 29)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 106, column 2 to column 29)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 107, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 108, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 109, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 110, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 115, column 2 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 116, column 2 to column 20)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 117, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 118, column 2 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 119, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 120, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 121, column 2 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 122, column 2 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 123, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 124, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 127, column 2 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 128, column 2 to column 34)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 129, column 2 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 130, column 2 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 131, column 2 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 132, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 133, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 134, column 2 to column 33)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 135, column 2 to column 33)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 211, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 212, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 213, column 2 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 214, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 215, column 2 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 216, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 219, column 2 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 220, column 2 to column 25)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 221, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 223, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 224, column 2 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 225, column 2 to column 44)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 227, column 2 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 228, column 2 to column 25)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 229, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 230, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 231, column 2 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 233, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 234, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 236, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 237, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 239, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 240, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 241, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 243, column 2 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 244, column 2 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 245, column 2 to column 35)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 246, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 266, column 2 to column 89)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 267, column 2 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 268, column 2 to column 18)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 271, column 4 to column 64)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 272, column 4 to column 64)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 270, column 16 to line 273, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 270, column 2 to line 273, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 275, column 3 to column 37)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 276, column 3 to column 37)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 278, column 4 to column 52)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 279, column 4 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 280, column 4 to column 51)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 281, column 4 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 285, column 4 to column 49)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 284, column 23 to line 286, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 284, column 2 to line 286, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 289, column 4 to column 60)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 288, column 23 to line 290, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 288, column 2 to line 290, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 294, column 4 to column 61)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 293, column 16 to line 295, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 293, column 2 to line 295, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 301, column 6 to column 52)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 300, column 4 to line 301, column 52)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 299, column 17 to line 302, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 299, column 2 to line 302, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 310, column 5 to column 50)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 309, column 23 to line 311, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 309, column 2 to line 311, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 314, column 5 to column 61)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 313, column 24 to line 315, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 313, column 3 to line 315, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 319, column 5 to column 62)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 318, column 17 to line 320, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 318, column 3 to line 320, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 326, column 7 to column 53)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 325, column 5 to line 326, column 53)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 324, column 18 to line 327, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 324, column 3 to line 327, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 334, column 6 to column 69)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 333, column 4 to line 334, column 69)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 336, column 6 to column 69)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 335, column 4 to line 336, column 69)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 332, column 17 to line 337, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 332, column 2 to line 337, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 141, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 141, column 13 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 141, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 142, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 142, column 13 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 142, column 2 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 143, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 143, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 143, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 144, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 144, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 145, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 145, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 145, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 146, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 146, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 147, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 147, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 147, column 2 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 148, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 148, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 149, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 149, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 149, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 150, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 150, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 152, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 153, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 154, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 158, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 159, column 2 to column 29)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 160, column 2 to column 29)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 161, column 2 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 162, column 2 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 163, column 2 to column 32)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 164, column 2 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 165, column 2 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 166, column 2 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 187, column 9 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 187, column 14 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 187, column 2 to column 89)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 188, column 2 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 191, column 4 to column 60)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 192, column 4 to column 60)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 190, column 16 to line 193, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 190, column 2 to line 193, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 196, column 2 to column 46)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 197, column 2 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 198, column 2 to column 45)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 199, column 2 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 202, column 4 to column 49)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 201, column 31 to line 203, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 201, column 2 to line 203, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 205, column 4 to column 48)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 204, column 31 to line 206, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 204, column 2 to line 206, column 4)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 45, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 46, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 47, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 48, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 49, column 2 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 50, column 2 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 52, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 52, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 52, column 2 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 53, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 53, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 53, column 2 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 54, column 10 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 54, column 14 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 54, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 55, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 55, column 14 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 55, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 56, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 56, column 14 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 56, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 57, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 57, column 12 to column 14)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 57, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 58, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 58, column 12 to column 14)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 58, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 62, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 63, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 64, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 65, column 2 to column 10)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 67, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 67, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 68, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 68, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 69, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 69, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 69, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 70, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 70, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 71, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 71, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 71, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 72, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 72, column 2 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 73, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 73, column 2 to column 20)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 75, column 4 to column 20)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 74, column 16 to line 76, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 74, column 2 to line 76, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 79, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 80, column 2 to column 24)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 83, column 4 to column 33)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 84, column 4 to column 33)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 82, column 16 to line 85, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 82, column 2 to line 85, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 86, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 87, column 2 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 89, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 90, column 2 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 91, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 92, column 2 to column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 102, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 103, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 107, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 108, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 115, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 116, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 121, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 122, column 9 to column 12)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 211, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 211, column 13 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 212, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 212, column 13 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 213, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 213, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 214, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 214, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 215, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 215, column 13 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 216, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 216, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 219, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 220, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 221, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 223, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 223, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 224, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 224, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 225, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 227, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 228, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 229, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 230, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 230, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 231, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 231, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 233, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 233, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 234, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 236, column 9 to column 11)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 236, column 12 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 237, column 9 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 266, column 9 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 266, column 14 to column 16)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 3, column 8 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 4, column 8 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 5, column 15 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 5, column 19 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 5, column 8 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 6, column 8 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 8, column 11 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 7, column 9 to line 8, column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 10, column 9 to column 54)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 11, column 9 to column 45)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 9, column 25 to line 12, column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 9, column 9 to line 12, column 9)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 13, column 7 to column 21)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 2, column 51 to line 14, column 5)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 16, column 4 to column 26)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 17, column 11 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 17, column 4 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 18, column 11 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 18, column 4 to column 33)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 19, column 11 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 19, column 4 to column 27)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 21, column 11 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 21, column 4 to column 54)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 22, column 11 to column 13)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 22, column 4 to column 54)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 23, column 4 to column 30)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 15, column 91 to line 24, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 28, column 11 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 28, column 4 to column 61)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 30, column 4 to column 23)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 27, column 101 to line 32, column 3)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 36, column 11 to column 19)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 36, column 20 to column 22)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 36, column 4 to column 28)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 37, column 4 to column 17)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 39, column 6 to column 68)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 38, column 26 to line 40, column 5)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 38, column 4 to line 40, column 5)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 41, column 4 to column 15)",
 " (in '/home/prior/vep_soft/VEP_INS_workflow_Internal/vep/stan/vep_sample_euler_bcorr_fast_both_EEG_SEEG.stan', line 35, column 96 to line 42, column 3)"};

struct ode_sol_functor__ {
  template <typename T0__, typename T2__, typename T3__, typename T4__,
            typename T5__, typename T6__, typename T7__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_col_vector_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
            stan::require_stan_scalar_t<T4__>* = nullptr,
            stan::require_stan_scalar_t<T5__>* = nullptr,
            stan::require_stan_scalar_t<T6__>* = nullptr,
            stan::require_col_vector_t<T7__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T2__>,
                       stan::value_type_t<T3__>, T4__, T5__,
                       stan::promote_args_t<T6__, stan::value_type_t<T7__>>>, -1, -1>
  operator()(const T0__& dt, const int& nt, const T2__& xz, const T3__& SC,
             const T4__& I1, const T5__& tau0, const T6__& K, const T7__& eta,
             std::ostream* pstream__) const;
};
struct correct_baseline_functor__ {
  template <typename T0__,
            stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  operator()(const T0__& Seeg, const int& n_bsl, std::ostream* pstream__) const;
};
struct ode_rhs_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__, typename T5__, typename T6__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_col_vector_t<T1__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
            stan::require_stan_scalar_t<T3__>* = nullptr,
            stan::require_stan_scalar_t<T4__>* = nullptr,
            stan::require_stan_scalar_t<T5__>* = nullptr,
            stan::require_col_vector_t<T6__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
                       stan::value_type_t<T2__>, T3__, T4__,
                       stan::promote_args_t<T5__, stan::value_type_t<T6__>>>, -1, 1>
  operator()(const T0__& time, const T1__& xz, const T2__& SC, const T3__& I1,
             const T4__& tau0, const T5__& K, const T6__& eta,
             std::ostream* pstream__) const;
};
struct ode_step_functor__ {
  template <typename T0__, typename T1__, typename T2__, typename T3__,
            typename T4__, typename T5__, typename T6__, typename T7__,
            stan::require_stan_scalar_t<T0__>* = nullptr,
            stan::require_stan_scalar_t<T1__>* = nullptr,
            stan::require_col_vector_t<T2__>* = nullptr,
            stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
            stan::require_stan_scalar_t<T4__>* = nullptr,
            stan::require_stan_scalar_t<T5__>* = nullptr,
            stan::require_stan_scalar_t<T6__>* = nullptr,
            stan::require_col_vector_t<T7__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
                       stan::value_type_t<T3__>, T4__,
                       stan::promote_args_t<T5__, T6__,
                                            stan::value_type_t<T7__>>>, -1, 1>
  operator()(const T0__& time, const T1__& dt, const T2__& xz, const T3__& SC,
             const T4__& I1, const T5__& tau0, const T6__& K, const T7__& eta,
             std::ostream* pstream__) const;
};

template <typename T0__,
          stan::require_eigen_matrix_dynamic_t<T0__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
  correct_baseline(const T0__& Seeg_arg__, const int& n_bsl,
                   std::ostream* pstream__) {
    using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
    int current_statement__ = 0; 
    const auto& Seeg = stan::math::to_ref(Seeg_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int nt = std::numeric_limits<int>::min();
      current_statement__ = 263;
      nt = stan::math::rows(Seeg);
      int ns = std::numeric_limits<int>::min();
      current_statement__ = 264;
      ns = stan::math::cols(Seeg);
      current_statement__ = 265;
      stan::math::validate_non_negative_index("output", "nt", nt);
      current_statement__ = 266;
      stan::math::validate_non_negative_index("output", "ns", ns);
      Eigen::Matrix<local_scalar_t__, -1, -1> output =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nt, ns,
           DUMMY_VAR__);
      local_scalar_t__ bsl_value = DUMMY_VAR__;
      current_statement__ = 270;
      if (stan::math::logical_eq(n_bsl, 0)) {
        current_statement__ = 269;
        return Seeg;
      } 
      current_statement__ = 274;
      for (int s = 1; s <= ns; ++s) {
        current_statement__ = 271;
        bsl_value = stan::math::mean(stan::math::sub_col(Seeg, 1, s, n_bsl));
        current_statement__ = 272;
        stan::model::assign(output,
          stan::math::subtract(
            stan::model::rvalue(Seeg, "Seeg",
              stan::model::index_omni(), stan::model::index_uni(s)),
            bsl_value),
          "assigning variable output", stan::model::index_omni(),
                                         stan::model::index_uni(s));
      }
      current_statement__ = 275;
      return output;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_col_vector_t<T1__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T2__>* = nullptr,
          stan::require_stan_scalar_t<T3__>* = nullptr,
          stan::require_stan_scalar_t<T4__>* = nullptr,
          stan::require_stan_scalar_t<T5__>* = nullptr,
          stan::require_col_vector_t<T6__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
                     stan::value_type_t<T2__>, T3__, T4__,
                     stan::promote_args_t<T5__, stan::value_type_t<T6__>>>, -1, 1>
  ode_rhs(const T0__& time, const T1__& xz_arg__, const T2__& SC_arg__,
          const T3__& I1, const T4__& tau0, const T5__& K,
          const T6__& eta_arg__, std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, stan::value_type_t<T1__>,
                                 stan::value_type_t<T2__>, T3__, T4__,
                                 stan::promote_args_t<T5__,
                                                      stan::value_type_t<T6__>>>;
    int current_statement__ = 0; 
    const auto& xz = stan::math::to_ref(xz_arg__);
    const auto& SC = stan::math::to_ref(SC_arg__);
    const auto& eta = stan::math::to_ref(eta_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int nn = std::numeric_limits<int>::min();
      current_statement__ = 277;
      nn = (stan::math::rows(xz) / 2);
      current_statement__ = 278;
      stan::math::validate_non_negative_index("x", "nn", nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> x =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 279;
      stan::model::assign(x,
        stan::model::rvalue(xz, "xz", stan::model::index_min_max(1, nn)),
        "assigning variable x");
      current_statement__ = 280;
      stan::math::validate_non_negative_index("z", "nn", nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> z =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 281;
      stan::model::assign(z,
        stan::model::rvalue(xz, "xz",
          stan::model::index_min_max((nn + 1), (2 * nn))),
        "assigning variable z");
      current_statement__ = 282;
      stan::math::validate_non_negative_index("gx", "nn", nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> gx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 283;
      stan::model::assign(gx, stan::math::multiply(SC, x),
        "assigning variable gx");
      current_statement__ = 284;
      stan::math::validate_non_negative_index("dx", "nn", nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> dx =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 285;
      stan::model::assign(dx,
        stan::math::add(
          stan::math::subtract(
            stan::math::subtract(
              stan::math::subtract(1.0,
                stan::math::elt_multiply(stan::math::elt_multiply(x, x), x)),
              stan::math::elt_multiply(stan::math::multiply(2.0, x), x)), z),
          I1), "assigning variable dx");
      current_statement__ = 286;
      stan::math::validate_non_negative_index("dz", "nn", nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> dz =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 287;
      stan::model::assign(dz,
        stan::math::multiply((1 / tau0),
          stan::math::subtract(
            stan::math::subtract(
              stan::math::multiply(4, stan::math::subtract(x, eta)), z),
            stan::math::multiply(K, gx))), "assigning variable dz");
      current_statement__ = 288;
      return stan::math::append_row(dx, dz);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_stan_scalar_t<T1__>* = nullptr,
          stan::require_col_vector_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
          stan::require_stan_scalar_t<T4__>* = nullptr,
          stan::require_stan_scalar_t<T5__>* = nullptr,
          stan::require_stan_scalar_t<T6__>* = nullptr,
          stan::require_col_vector_t<T7__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
                     stan::value_type_t<T3__>, T4__,
                     stan::promote_args_t<T5__, T6__,
                                          stan::value_type_t<T7__>>>, -1, 1>
  ode_step(const T0__& time, const T1__& dt, const T2__& xz_arg__,
           const T3__& SC_arg__, const T4__& I1, const T5__& tau0,
           const T6__& K, const T7__& eta_arg__, std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>, T4__,
                                 stan::promote_args_t<T5__, T6__,
                                                      stan::value_type_t<T7__>>>;
    int current_statement__ = 0; 
    const auto& xz = stan::math::to_ref(xz_arg__);
    const auto& SC = stan::math::to_ref(SC_arg__);
    const auto& eta = stan::math::to_ref(eta_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 290;
      stan::math::validate_non_negative_index("dxz", "rows(xz)",
                                              stan::math::rows(xz));
      Eigen::Matrix<local_scalar_t__, -1, 1> dxz =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(
           stan::math::rows(xz), DUMMY_VAR__);
      current_statement__ = 291;
      stan::model::assign(dxz,
        ode_rhs(time, xz, SC, I1, tau0, K, eta, pstream__),
        "assigning variable dxz");
      current_statement__ = 292;
      return stan::math::add(xz, stan::math::multiply(dt, dxz));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T2__, typename T3__, typename T4__,
          typename T5__, typename T6__, typename T7__,
          stan::require_stan_scalar_t<T0__>* = nullptr,
          stan::require_col_vector_t<T2__>* = nullptr,
          stan::require_eigen_matrix_dynamic_t<T3__>* = nullptr,
          stan::require_stan_scalar_t<T4__>* = nullptr,
          stan::require_stan_scalar_t<T5__>* = nullptr,
          stan::require_stan_scalar_t<T6__>* = nullptr,
          stan::require_col_vector_t<T7__>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T2__>,
                     stan::value_type_t<T3__>, T4__, T5__,
                     stan::promote_args_t<T6__, stan::value_type_t<T7__>>>, -1, -1>
  ode_sol(const T0__& dt, const int& nt, const T2__& xz_arg__,
          const T3__& SC_arg__, const T4__& I1, const T5__& tau0,
          const T6__& K, const T7__& eta_arg__, std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, stan::value_type_t<T2__>,
                                 stan::value_type_t<T3__>, T4__, T5__,
                                 stan::promote_args_t<T6__,
                                                      stan::value_type_t<T7__>>>;
    int current_statement__ = 0; 
    const auto& xz = stan::math::to_ref(xz_arg__);
    const auto& SC = stan::math::to_ref(SC_arg__);
    const auto& eta = stan::math::to_ref(eta_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 294;
      stan::math::validate_non_negative_index("sol", "rows(xz)",
                                              stan::math::rows(xz));
      current_statement__ = 295;
      stan::math::validate_non_negative_index("sol", "nt", nt);
      Eigen::Matrix<local_scalar_t__, -1, -1> sol =
         Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(
           stan::math::rows(xz), nt, DUMMY_VAR__);
      current_statement__ = 297;
      stan::model::assign(sol, xz,
        "assigning variable sol", stan::model::index_omni(),
                                    stan::model::index_uni(1));
      current_statement__ = 300;
      for (int t = 1; t <= (nt - 1); ++t) {
        current_statement__ = 298;
        stan::model::assign(sol,
          ode_step((t * dt), dt,
            stan::model::deep_copy(
              stan::model::rvalue(sol, "sol",
                stan::model::index_omni(), stan::model::index_uni(t))), SC,
            I1, tau0, K, eta, pstream__),
          "assigning variable sol", stan::model::index_omni(),
                                      stan::model::index_uni((t + 1)));
      }
      current_statement__ = 301;
      return sol;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <typename T0__, typename T2__, typename T3__, typename T4__,
          typename T5__, typename T6__, typename T7__,
          stan::require_stan_scalar_t<T0__>*,
          stan::require_col_vector_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*,
          stan::require_stan_scalar_t<T4__>*,
          stan::require_stan_scalar_t<T5__>*,
          stan::require_stan_scalar_t<T6__>*,
          stan::require_col_vector_t<T7__>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T2__>,
                     stan::value_type_t<T3__>, T4__, T5__,
                     stan::promote_args_t<T6__, stan::value_type_t<T7__>>>, -1, -1>
ode_sol_functor__::operator()(const T0__& dt, const int& nt, const T2__& xz,
                              const T3__& SC, const T4__& I1,
                              const T5__& tau0, const T6__& K,
                              const T7__& eta, std::ostream* pstream__) 
const
{
  return ode_sol(dt, nt, xz, SC, I1, tau0, K, eta, pstream__);
}

template <typename T0__, stan::require_eigen_matrix_dynamic_t<T0__>*>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
correct_baseline_functor__::operator()(const T0__& Seeg, const int& n_bsl,
                                       std::ostream* pstream__)  const
{
  return correct_baseline(Seeg, n_bsl, pstream__);
}

template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__,
          stan::require_stan_scalar_t<T0__>*,
          stan::require_col_vector_t<T1__>*,
          stan::require_eigen_matrix_dynamic_t<T2__>*,
          stan::require_stan_scalar_t<T3__>*,
          stan::require_stan_scalar_t<T4__>*,
          stan::require_stan_scalar_t<T5__>*,
          stan::require_col_vector_t<T6__>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::value_type_t<T1__>,
                     stan::value_type_t<T2__>, T3__, T4__,
                     stan::promote_args_t<T5__, stan::value_type_t<T6__>>>, -1, 1>
ode_rhs_functor__::operator()(const T0__& time, const T1__& xz,
                              const T2__& SC, const T3__& I1,
                              const T4__& tau0, const T5__& K,
                              const T6__& eta, std::ostream* pstream__) 
const
{
  return ode_rhs(time, xz, SC, I1, tau0, K, eta, pstream__);
}

template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__, typename T5__, typename T6__, typename T7__,
          stan::require_stan_scalar_t<T0__>*,
          stan::require_stan_scalar_t<T1__>*,
          stan::require_col_vector_t<T2__>*,
          stan::require_eigen_matrix_dynamic_t<T3__>*,
          stan::require_stan_scalar_t<T4__>*,
          stan::require_stan_scalar_t<T5__>*,
          stan::require_stan_scalar_t<T6__>*,
          stan::require_col_vector_t<T7__>*>
Eigen::Matrix<stan::promote_args_t<T0__, T1__, stan::value_type_t<T2__>,
                     stan::value_type_t<T3__>, T4__,
                     stan::promote_args_t<T5__, T6__,
                                          stan::value_type_t<T7__>>>, -1, 1>
ode_step_functor__::operator()(const T0__& time, const T1__& dt,
                               const T2__& xz, const T3__& SC,
                               const T4__& I1, const T5__& tau0,
                               const T6__& K, const T7__& eta,
                               std::ostream* pstream__)  const
{
  return ode_step(time, dt, xz, SC, I1, tau0, K, eta, pstream__);
}


class vep_sample_euler_bcorr_fast_both_EEG_SEEG_model final : public model_base_crtp<vep_sample_euler_bcorr_fast_both_EEG_SEEG_model> {

 private:
  int nn;
  int nt;
  int ns1;
  int ns2;
  int nbs1;
  int nbs2;
  Eigen::Matrix<double, -1, -1> Obs1__;
  Eigen::Matrix<double, -1, -1> Obs2__;
  Eigen::Matrix<double, -1, -1> SC__;
  Eigen::Matrix<double, -1, -1> gain1__;
  Eigen::Matrix<double, -1, -1> gain2__;
  Eigen::Matrix<double, -1, -1> eig1__;
  Eigen::Matrix<double, -1, -1> eig2__;
  double dt;
  double tau0;
  double I1;
  double Ks;
  Eigen::Matrix<double, -1, 1> xs1__;
  Eigen::Matrix<double, -1, 1> xs2__;
  Eigen::Matrix<double, -1, -1> wtm1__;
  Eigen::Matrix<double, -1, 1> wt1__;
  Eigen::Matrix<double, -1, -1> wtm2__;
  Eigen::Matrix<double, -1, 1> wt2__;
  Eigen::Matrix<double, -1, 1> x_init__;
  int xhat_qqc_1_1dim__;
  int x_ppc_1_1dim__;
  int log_lik_1_1dim__;
  int xhat_qqc_2_1dim__;
  int x_ppc_2_1dim__;
  int log_lik_2_1dim__;
  int SEEG_1dim__;
  int EEG_1dim__;
  int sol_1dim__; 
  Eigen::Map<Eigen::Matrix<double, -1, -1>> Obs1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> Obs2{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> SC{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> gain1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> gain2{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> eig1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> eig2{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> xs1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> xs2{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> wtm1{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> wt1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> wtm2{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> wt2{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> x_init{nullptr, 0};
 
 public:
  ~vep_sample_euler_bcorr_fast_both_EEG_SEEG_model() { }
  
  inline std::string model_name() const final { return "vep_sample_euler_bcorr_fast_both_EEG_SEEG_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.29.2", "stancflags = "};
  }
  
  
  vep_sample_euler_bcorr_fast_both_EEG_SEEG_model(stan::io::var_context& context__,
                                                  unsigned int random_seed__ = 0,
                                                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace::vep_sample_euler_bcorr_fast_both_EEG_SEEG_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 158;
      context__.validate_dims("data initialization","nn","int",
           std::vector<size_t>{});
      nn = std::numeric_limits<int>::min();
      
      
      current_statement__ = 158;
      nn = context__.vals_i("nn")[(1 - 1)];
      current_statement__ = 159;
      context__.validate_dims("data initialization","nt","int",
           std::vector<size_t>{});
      nt = std::numeric_limits<int>::min();
      
      
      current_statement__ = 159;
      nt = context__.vals_i("nt")[(1 - 1)];
      current_statement__ = 160;
      context__.validate_dims("data initialization","ns1","int",
           std::vector<size_t>{});
      ns1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 160;
      ns1 = context__.vals_i("ns1")[(1 - 1)];
      current_statement__ = 161;
      context__.validate_dims("data initialization","ns2","int",
           std::vector<size_t>{});
      ns2 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 161;
      ns2 = context__.vals_i("ns2")[(1 - 1)];
      current_statement__ = 162;
      context__.validate_dims("data initialization","nbs1","int",
           std::vector<size_t>{});
      nbs1 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 162;
      nbs1 = context__.vals_i("nbs1")[(1 - 1)];
      current_statement__ = 163;
      context__.validate_dims("data initialization","nbs2","int",
           std::vector<size_t>{});
      nbs2 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 163;
      nbs2 = context__.vals_i("nbs2")[(1 - 1)];
      current_statement__ = 164;
      stan::math::validate_non_negative_index("Obs1", "nt", nt);
      current_statement__ = 165;
      stan::math::validate_non_negative_index("Obs1", "ns1", ns1);
      current_statement__ = 166;
      context__.validate_dims("data initialization","Obs1","double",
           std::vector<size_t>{static_cast<size_t>(nt),
            static_cast<size_t>(ns1)});
      Obs1__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
          std::numeric_limits<double>::quiet_NaN());
      new (&Obs1) Eigen::Map<Eigen::Matrix<double, -1, -1>>(Obs1__.data(), nt, ns1);
        
      
      {
        std::vector<local_scalar_t__> Obs1_flat__;
        current_statement__ = 166;
        Obs1_flat__ = context__.vals_r("Obs1");
        current_statement__ = 166;
        pos__ = 1;
        current_statement__ = 166;
        for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
          current_statement__ = 166;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 166;
            stan::model::assign(Obs1, Obs1_flat__[(pos__ - 1)],
              "assigning variable Obs1", stan::model::index_uni(sym2__),
                                           stan::model::index_uni(sym1__));
            current_statement__ = 166;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 167;
      stan::math::validate_non_negative_index("Obs2", "nt", nt);
      current_statement__ = 168;
      stan::math::validate_non_negative_index("Obs2", "ns2", ns2);
      current_statement__ = 169;
      context__.validate_dims("data initialization","Obs2","double",
           std::vector<size_t>{static_cast<size_t>(nt),
            static_cast<size_t>(ns2)});
      Obs2__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
          std::numeric_limits<double>::quiet_NaN());
      new (&Obs2) Eigen::Map<Eigen::Matrix<double, -1, -1>>(Obs2__.data(), nt, ns2);
        
      
      {
        std::vector<local_scalar_t__> Obs2_flat__;
        current_statement__ = 169;
        Obs2_flat__ = context__.vals_r("Obs2");
        current_statement__ = 169;
        pos__ = 1;
        current_statement__ = 169;
        for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
          current_statement__ = 169;
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            current_statement__ = 169;
            stan::model::assign(Obs2, Obs2_flat__[(pos__ - 1)],
              "assigning variable Obs2", stan::model::index_uni(sym2__),
                                           stan::model::index_uni(sym1__));
            current_statement__ = 169;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 170;
      stan::math::validate_non_negative_index("SC", "nn", nn);
      current_statement__ = 171;
      stan::math::validate_non_negative_index("SC", "nn", nn);
      current_statement__ = 172;
      context__.validate_dims("data initialization","SC","double",
           std::vector<size_t>{static_cast<size_t>(nn),
            static_cast<size_t>(nn)});
      SC__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nn, nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&SC) Eigen::Map<Eigen::Matrix<double, -1, -1>>(SC__.data(), nn, nn);
        
      
      {
        std::vector<local_scalar_t__> SC_flat__;
        current_statement__ = 172;
        SC_flat__ = context__.vals_r("SC");
        current_statement__ = 172;
        pos__ = 1;
        current_statement__ = 172;
        for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
          current_statement__ = 172;
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            current_statement__ = 172;
            stan::model::assign(SC, SC_flat__[(pos__ - 1)],
              "assigning variable SC", stan::model::index_uni(sym2__),
                                         stan::model::index_uni(sym1__));
            current_statement__ = 172;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 173;
      stan::math::validate_non_negative_index("gain1", "ns1", ns1);
      current_statement__ = 174;
      stan::math::validate_non_negative_index("gain1", "nn", nn);
      current_statement__ = 175;
      context__.validate_dims("data initialization","gain1","double",
           std::vector<size_t>{static_cast<size_t>(ns1),
            static_cast<size_t>(nn)});
      gain1__ = 
        Eigen::Matrix<double, -1, -1>::Constant(ns1, nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&gain1) Eigen::Map<Eigen::Matrix<double, -1, -1>>(gain1__.data(), ns1, nn);
        
      
      {
        std::vector<local_scalar_t__> gain1_flat__;
        current_statement__ = 175;
        gain1_flat__ = context__.vals_r("gain1");
        current_statement__ = 175;
        pos__ = 1;
        current_statement__ = 175;
        for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
          current_statement__ = 175;
          for (int sym2__ = 1; sym2__ <= ns1; ++sym2__) {
            current_statement__ = 175;
            stan::model::assign(gain1, gain1_flat__[(pos__ - 1)],
              "assigning variable gain1", stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
            current_statement__ = 175;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 176;
      stan::math::validate_non_negative_index("gain2", "ns2", ns2);
      current_statement__ = 177;
      stan::math::validate_non_negative_index("gain2", "nn", nn);
      current_statement__ = 178;
      context__.validate_dims("data initialization","gain2","double",
           std::vector<size_t>{static_cast<size_t>(ns2),
            static_cast<size_t>(nn)});
      gain2__ = 
        Eigen::Matrix<double, -1, -1>::Constant(ns2, nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&gain2) Eigen::Map<Eigen::Matrix<double, -1, -1>>(gain2__.data(), ns2, nn);
        
      
      {
        std::vector<local_scalar_t__> gain2_flat__;
        current_statement__ = 178;
        gain2_flat__ = context__.vals_r("gain2");
        current_statement__ = 178;
        pos__ = 1;
        current_statement__ = 178;
        for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
          current_statement__ = 178;
          for (int sym2__ = 1; sym2__ <= ns2; ++sym2__) {
            current_statement__ = 178;
            stan::model::assign(gain2, gain2_flat__[(pos__ - 1)],
              "assigning variable gain2", stan::model::index_uni(sym2__),
                                            stan::model::index_uni(sym1__));
            current_statement__ = 178;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 179;
      stan::math::validate_non_negative_index("eig1", "nn", nn);
      current_statement__ = 180;
      stan::math::validate_non_negative_index("eig1", "nn", nn);
      current_statement__ = 181;
      context__.validate_dims("data initialization","eig1","double",
           std::vector<size_t>{static_cast<size_t>(nn),
            static_cast<size_t>(nn)});
      eig1__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nn, nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&eig1) Eigen::Map<Eigen::Matrix<double, -1, -1>>(eig1__.data(), nn, nn);
        
      
      {
        std::vector<local_scalar_t__> eig1_flat__;
        current_statement__ = 181;
        eig1_flat__ = context__.vals_r("eig1");
        current_statement__ = 181;
        pos__ = 1;
        current_statement__ = 181;
        for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
          current_statement__ = 181;
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            current_statement__ = 181;
            stan::model::assign(eig1, eig1_flat__[(pos__ - 1)],
              "assigning variable eig1", stan::model::index_uni(sym2__),
                                           stan::model::index_uni(sym1__));
            current_statement__ = 181;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 182;
      stan::math::validate_non_negative_index("eig2", "nn", nn);
      current_statement__ = 183;
      stan::math::validate_non_negative_index("eig2", "nn", nn);
      current_statement__ = 184;
      context__.validate_dims("data initialization","eig2","double",
           std::vector<size_t>{static_cast<size_t>(nn),
            static_cast<size_t>(nn)});
      eig2__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nn, nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&eig2) Eigen::Map<Eigen::Matrix<double, -1, -1>>(eig2__.data(), nn, nn);
        
      
      {
        std::vector<local_scalar_t__> eig2_flat__;
        current_statement__ = 184;
        eig2_flat__ = context__.vals_r("eig2");
        current_statement__ = 184;
        pos__ = 1;
        current_statement__ = 184;
        for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
          current_statement__ = 184;
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            current_statement__ = 184;
            stan::model::assign(eig2, eig2_flat__[(pos__ - 1)],
              "assigning variable eig2", stan::model::index_uni(sym2__),
                                           stan::model::index_uni(sym1__));
            current_statement__ = 184;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 185;
      dt = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 186;
      tau0 = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 187;
      I1 = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 188;
      Ks = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 189;
      stan::math::validate_non_negative_index("xs1", "nt * ns1", (nt * ns1));
      current_statement__ = 190;
      xs1__ = 
        Eigen::Matrix<double, -1, 1>::Constant((nt * ns1),
          std::numeric_limits<double>::quiet_NaN());
      new (&xs1) Eigen::Map<Eigen::Matrix<double, -1, 1>>(xs1__.data(), 
        (nt * ns1));
      
      current_statement__ = 191;
      stan::math::validate_non_negative_index("xs2", "nt * ns2", (nt * ns2));
      current_statement__ = 192;
      xs2__ = 
        Eigen::Matrix<double, -1, 1>::Constant((nt * ns2),
          std::numeric_limits<double>::quiet_NaN());
      new (&xs2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(xs2__.data(), 
        (nt * ns2));
      
      current_statement__ = 193;
      stan::math::validate_non_negative_index("wtm1", "nt", nt);
      current_statement__ = 194;
      stan::math::validate_non_negative_index("wtm1", "ns1", ns1);
      current_statement__ = 195;
      wtm1__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
          std::numeric_limits<double>::quiet_NaN());
      new (&wtm1) Eigen::Map<Eigen::Matrix<double, -1, -1>>(wtm1__.data(), nt, ns1);
        
      
      current_statement__ = 196;
      stan::math::validate_non_negative_index("wt1", "nt * ns1", (nt * ns1));
      current_statement__ = 197;
      wt1__ = 
        Eigen::Matrix<double, -1, 1>::Constant((nt * ns1),
          std::numeric_limits<double>::quiet_NaN());
      new (&wt1) Eigen::Map<Eigen::Matrix<double, -1, 1>>(wt1__.data(), 
        (nt * ns1));
      
      current_statement__ = 198;
      stan::math::validate_non_negative_index("wtm2", "nt", nt);
      current_statement__ = 199;
      stan::math::validate_non_negative_index("wtm2", "ns2", ns2);
      current_statement__ = 200;
      wtm2__ = 
        Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
          std::numeric_limits<double>::quiet_NaN());
      new (&wtm2) Eigen::Map<Eigen::Matrix<double, -1, -1>>(wtm2__.data(), nt, ns2);
        
      
      current_statement__ = 201;
      stan::math::validate_non_negative_index("wt2", "nt * ns2", (nt * ns2));
      current_statement__ = 202;
      wt2__ = 
        Eigen::Matrix<double, -1, 1>::Constant((nt * ns2),
          std::numeric_limits<double>::quiet_NaN());
      new (&wt2) Eigen::Map<Eigen::Matrix<double, -1, 1>>(wt2__.data(), 
        (nt * ns2));
      
      current_statement__ = 203;
      stan::math::validate_non_negative_index("x_init", "nn", nn);
      current_statement__ = 204;
      x_init__ = 
        Eigen::Matrix<double, -1, 1>::Constant(nn,
          std::numeric_limits<double>::quiet_NaN());
      new (&x_init) Eigen::Map<Eigen::Matrix<double, -1, 1>>(x_init__.data(), nn);
        
      
      current_statement__ = 207;
      for (int i = 1; i <= nn; ++i) {
        current_statement__ = 205;
        stan::model::assign(x_init, -1.98,
          "assigning variable x_init", stan::model::index_uni(i));
      }
      current_statement__ = 208;
      stan::model::assign(xs1, stan::math::to_vector(Obs1),
        "assigning variable xs1");
      current_statement__ = 209;
      stan::model::assign(xs2, stan::math::to_vector(Obs2),
        "assigning variable xs2");
      current_statement__ = 213;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 210;
        stan::model::assign(wtm1,
          stan::math::subtract(
            stan::model::rvalue(Obs1, "Obs1",
              stan::model::index_uni(i), stan::model::index_omni()),
            stan::model::rvalue(Obs1, "Obs1",
              stan::model::index_uni(1), stan::model::index_omni())),
          "assigning variable wtm1", stan::model::index_uni(i),
                                       stan::model::index_omni());
        current_statement__ = 211;
        stan::model::assign(wtm2,
          stan::math::subtract(
            stan::model::rvalue(Obs2, "Obs2",
              stan::model::index_uni(i), stan::model::index_omni()),
            stan::model::rvalue(Obs2, "Obs2",
              stan::model::index_uni(1), stan::model::index_omni())),
          "assigning variable wtm2", stan::model::index_uni(i),
                                       stan::model::index_omni());
      }
      current_statement__ = 214;
      stan::model::assign(wt1, stan::math::to_vector(wtm1),
        "assigning variable wt1");
      current_statement__ = 215;
      stan::model::assign(wt2, stan::math::to_vector(wtm2),
        "assigning variable wt2");
      current_statement__ = 216;
      dt = 0.1;
      current_statement__ = 217;
      tau0 = 15.0;
      current_statement__ = 218;
      I1 = 3.1;
      current_statement__ = 219;
      Ks = 1.0;
      current_statement__ = 220;
      stan::math::validate_non_negative_index("z_init_star", "nn", nn);
      current_statement__ = 221;
      stan::math::validate_non_negative_index("x0_star", "nn", nn);
      current_statement__ = 222;
      stan::math::validate_non_negative_index("u1_star", "ns1", ns1);
      current_statement__ = 223;
      stan::math::validate_non_negative_index("u2_star", "ns2", ns2);
      current_statement__ = 224;
      stan::math::validate_non_negative_index("x0", "nn", nn);
      current_statement__ = 225;
      stan::math::validate_non_negative_index("z_init", "nn", nn);
      current_statement__ = 226;
      stan::math::validate_non_negative_index("u1", "ns1", ns1);
      current_statement__ = 227;
      stan::math::validate_non_negative_index("u2", "ns2", ns2);
      current_statement__ = 228;
      stan::math::validate_non_negative_index("x", "nn", nn);
      current_statement__ = 229;
      stan::math::validate_non_negative_index("x", "nt", nt);
      current_statement__ = 230;
      stan::math::validate_non_negative_index("z", "nn", nn);
      current_statement__ = 231;
      stan::math::validate_non_negative_index("z", "nt", nt);
      current_statement__ = 232;
      stan::math::validate_non_negative_index("xhat_qqc2_1", "nt", nt);
      current_statement__ = 233;
      stan::math::validate_non_negative_index("xhat_qqc2_1", "ns1", ns1);
      current_statement__ = 234;
      stan::math::validate_non_negative_index("xhat_q2_1", "nt", nt);
      current_statement__ = 235;
      stan::math::validate_non_negative_index("xhat_q2_1", "ns1", ns1);
      current_statement__ = 236;
      stan::math::validate_non_negative_index("xhat_qqc2_2", "nt", nt);
      current_statement__ = 237;
      stan::math::validate_non_negative_index("xhat_qqc2_2", "ns2", ns2);
      current_statement__ = 238;
      stan::math::validate_non_negative_index("xhat_q2_2", "nt", nt);
      current_statement__ = 239;
      stan::math::validate_non_negative_index("xhat_q2_2", "ns2", ns2);
      current_statement__ = 240;
      xhat_qqc_1_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 240;
      xhat_qqc_1_1dim__ = (nt * ns1);
      current_statement__ = 240;
      stan::math::validate_non_negative_index("xhat_qqc_1", "nt * ns1",
                                              xhat_qqc_1_1dim__);
      current_statement__ = 241;
      x_ppc_1_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 241;
      x_ppc_1_1dim__ = (nt * ns1);
      current_statement__ = 241;
      stan::math::validate_non_negative_index("x_ppc_1", "nt * ns1",
                                              x_ppc_1_1dim__);
      current_statement__ = 242;
      log_lik_1_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 242;
      log_lik_1_1dim__ = (nt * ns1);
      current_statement__ = 242;
      stan::math::validate_non_negative_index("log_lik_1", "nt * ns1",
                                              log_lik_1_1dim__);
      current_statement__ = 243;
      stan::math::validate_non_negative_index("xhat_q_1", "nt", nt);
      current_statement__ = 244;
      stan::math::validate_non_negative_index("xhat_q_1", "ns1", ns1);
      current_statement__ = 245;
      stan::math::validate_non_negative_index("x_p_1", "nt", nt);
      current_statement__ = 246;
      stan::math::validate_non_negative_index("x_p_1", "ns1", ns1);
      current_statement__ = 247;
      stan::math::validate_non_negative_index("log_lik_sum", "nt", nt);
      current_statement__ = 248;
      xhat_qqc_2_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 248;
      xhat_qqc_2_1dim__ = (nt * ns2);
      current_statement__ = 248;
      stan::math::validate_non_negative_index("xhat_qqc_2", "nt * ns2",
                                              xhat_qqc_2_1dim__);
      current_statement__ = 249;
      x_ppc_2_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 249;
      x_ppc_2_1dim__ = (nt * ns2);
      current_statement__ = 249;
      stan::math::validate_non_negative_index("x_ppc_2", "nt * ns2",
                                              x_ppc_2_1dim__);
      current_statement__ = 250;
      log_lik_2_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 250;
      log_lik_2_1dim__ = (nt * ns2);
      current_statement__ = 250;
      stan::math::validate_non_negative_index("log_lik_2", "nt * ns2",
                                              log_lik_2_1dim__);
      current_statement__ = 251;
      stan::math::validate_non_negative_index("xhat_q_2", "nt", nt);
      current_statement__ = 252;
      stan::math::validate_non_negative_index("xhat_q_2", "ns2", ns2);
      current_statement__ = 253;
      stan::math::validate_non_negative_index("x_p_2", "nt", nt);
      current_statement__ = 254;
      stan::math::validate_non_negative_index("x_p_2", "ns2", ns2);
      current_statement__ = 255;
      stan::math::validate_non_negative_index("SEEG_bcor", "nt", nt);
      current_statement__ = 256;
      stan::math::validate_non_negative_index("SEEG_bcor", "ns1", ns1);
      current_statement__ = 257;
      SEEG_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 257;
      SEEG_1dim__ = (nt * ns1);
      current_statement__ = 257;
      stan::math::validate_non_negative_index("SEEG", "nt * ns1", SEEG_1dim__);
      current_statement__ = 258;
      stan::math::validate_non_negative_index("EEG_bcor", "nt", nt);
      current_statement__ = 259;
      stan::math::validate_non_negative_index("EEG_bcor", "ns2", ns2);
      current_statement__ = 260;
      EEG_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 260;
      EEG_1dim__ = (nt * ns2);
      current_statement__ = 260;
      stan::math::validate_non_negative_index("EEG", "nt * ns2", EEG_1dim__);
      current_statement__ = 261;
      sol_1dim__ = std::numeric_limits<int>::min();
      
      
      current_statement__ = 261;
      sol_1dim__ = (2 * nn);
      current_statement__ = 261;
      stan::math::validate_non_negative_index("sol", "2 * nn", sol_1dim__);
      current_statement__ = 262;
      stan::math::validate_non_negative_index("sol", "nt", nt);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = nn + nn + 1 + 1 + 1 + ns1 + ns2 + 1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> z_init_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 1;
      z_init_star = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(nn);
      Eigen::Matrix<local_scalar_t__, -1, 1> x0_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      current_statement__ = 2;
      x0_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nn);
      local_scalar_t__ K_star = DUMMY_VAR__;
      current_statement__ = 3;
      K_star = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 -1.0, lp__);
      local_scalar_t__ amp1_star = DUMMY_VAR__;
      current_statement__ = 4;
      amp1_star = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0.0, lp__);
      local_scalar_t__ amp2_star = DUMMY_VAR__;
      current_statement__ = 5;
      amp2_star = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0.0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> u1_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns1, DUMMY_VAR__);
      current_statement__ = 6;
      u1_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  ns1);
      Eigen::Matrix<local_scalar_t__, -1, 1> u2_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns2, DUMMY_VAR__);
      current_statement__ = 7;
      u2_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  ns2);
      local_scalar_t__ log_eps1_sq = DUMMY_VAR__;
      current_statement__ = 8;
      log_eps1_sq = in__.template read<local_scalar_t__>();
      local_scalar_t__ log_eps2_sq = DUMMY_VAR__;
      current_statement__ = 9;
      log_eps2_sq = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> x0 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> z_init =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      local_scalar_t__ K = DUMMY_VAR__;
      local_scalar_t__ amp = DUMMY_VAR__;
      local_scalar_t__ amp1 = DUMMY_VAR__;
      local_scalar_t__ amp2 = DUMMY_VAR__;
      Eigen::Matrix<local_scalar_t__, -1, 1> u1 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns1, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__, -1, 1> u2 =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns2, DUMMY_VAR__);
      local_scalar_t__ eps1 = DUMMY_VAR__;
      local_scalar_t__ eps2 = DUMMY_VAR__;
      current_statement__ = 20;
      stan::model::assign(x0,
        stan::math::add(-3.0,
          stan::math::multiply(stan::math::multiply(0.30, eig1), x0_star)),
        "assigning variable x0");
      current_statement__ = 21;
      stan::model::assign(z_init,
        stan::math::add(4.1,
          stan::math::multiply(stan::math::multiply(0.1, eig1), z_init_star)),
        "assigning variable z_init");
      current_statement__ = 22;
      K = (Ks + (1.0 * K_star));
      current_statement__ = 23;
      amp1 = (0.005 + (0.01 * amp1_star));
      current_statement__ = 24;
      amp2 = (0.005 + (0.01 * amp2_star));
      current_statement__ = 25;
      stan::model::assign(u1,
        stan::math::add(2.0, stan::math::multiply(1.0, u1_star)),
        "assigning variable u1");
      current_statement__ = 26;
      stan::model::assign(u2,
        stan::math::add(2.0, stan::math::multiply(1.0, u2_star)),
        "assigning variable u2");
      current_statement__ = 27;
      eps1 = stan::math::exp(((0.33 * log_eps1_sq) - 3.0));
      current_statement__ = 28;
      eps2 = stan::math::exp(((0.33 * log_eps2_sq) - 3.0));
      {
        current_statement__ = 102;
        stan::math::validate_non_negative_index("x", "nn", nn);
        current_statement__ = 103;
        stan::math::validate_non_negative_index("x", "nt", nt);
        Eigen::Matrix<local_scalar_t__, -1, -1> x =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nn, nt,
             DUMMY_VAR__);
        current_statement__ = 105;
        stan::math::validate_non_negative_index("z", "nn", nn);
        current_statement__ = 106;
        stan::math::validate_non_negative_index("z", "nt", nt);
        Eigen::Matrix<local_scalar_t__, -1, -1> z =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nn, nt,
             DUMMY_VAR__);
        current_statement__ = 108;
        stan::math::validate_non_negative_index("xhat2_1", "nt", nt);
        current_statement__ = 109;
        stan::math::validate_non_negative_index("xhat2_1", "ns1", ns1);
        Eigen::Matrix<local_scalar_t__, -1, -1> xhat2_1 =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nt, ns1,
             DUMMY_VAR__);
        current_statement__ = 111;
        stan::math::validate_non_negative_index("xhat_1", "nt * ns1",
                                                (nt * ns1));
        Eigen::Matrix<local_scalar_t__, -1, 1> xhat_1 =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant((nt * ns1),
             DUMMY_VAR__);
        current_statement__ = 113;
        stan::math::validate_non_negative_index("xhat2_2", "nt", nt);
        current_statement__ = 114;
        stan::math::validate_non_negative_index("xhat2_2", "ns2", ns2);
        Eigen::Matrix<local_scalar_t__, -1, -1> xhat2_2 =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nt, ns2,
             DUMMY_VAR__);
        current_statement__ = 116;
        stan::math::validate_non_negative_index("xhat_2", "nt * ns2",
                                                (nt * ns2));
        Eigen::Matrix<local_scalar_t__, -1, 1> xhat_2 =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant((nt * ns2),
             DUMMY_VAR__);
        current_statement__ = 118;
        stan::math::validate_non_negative_index("SEEG_bcor", "nt", nt);
        current_statement__ = 119;
        stan::math::validate_non_negative_index("SEEG_bcor", "ns1", ns1);
        Eigen::Matrix<local_scalar_t__, -1, -1> SEEG_bcor =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nt, ns1,
             DUMMY_VAR__);
        current_statement__ = 121;
        stan::math::validate_non_negative_index("SEEG", "nt * ns1",
                                                (nt * ns1));
        Eigen::Matrix<local_scalar_t__, -1, 1> SEEG =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant((nt * ns1),
             DUMMY_VAR__);
        current_statement__ = 123;
        stan::math::validate_non_negative_index("EEG_bcor", "nt", nt);
        current_statement__ = 124;
        stan::math::validate_non_negative_index("EEG_bcor", "ns2", ns2);
        Eigen::Matrix<local_scalar_t__, -1, -1> EEG_bcor =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant(nt, ns2,
             DUMMY_VAR__);
        current_statement__ = 126;
        stan::math::validate_non_negative_index("EEG", "nt * ns2", (nt * ns2));
        Eigen::Matrix<local_scalar_t__, -1, 1> EEG =
           Eigen::Matrix<local_scalar_t__, -1, 1>::Constant((nt * ns2),
             DUMMY_VAR__);
        local_scalar_t__ dx = DUMMY_VAR__;
        local_scalar_t__ dz = DUMMY_VAR__;
        local_scalar_t__ gx = DUMMY_VAR__;
        current_statement__ = 131;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x0_star, 0., 1.));
        current_statement__ = 132;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(amp1_star, 0., 1.));
        current_statement__ = 133;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(amp2_star, 0., 1.));
        current_statement__ = 134;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(K_star, 0., 1.));
        current_statement__ = 135;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(log_eps1_sq, 0., 10.0));
        current_statement__ = 136;
        lp_accum__.add(
          stan::math::normal_lpdf<propto__>(log_eps2_sq, 0., 10.0));
        current_statement__ = 137;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(u1_star, 0., 1.0));
        current_statement__ = 138;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(u2_star, 0., 1.0));
        current_statement__ = 139;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(z_init_star, 0, 1.));
        current_statement__ = 140;
        stan::math::validate_non_negative_index("sol", "2 * nn", (2 * nn));
        current_statement__ = 141;
        stan::math::validate_non_negative_index("sol", "nt", nt);
        Eigen::Matrix<local_scalar_t__, -1, -1> sol =
           Eigen::Matrix<local_scalar_t__, -1, -1>::Constant((2 * nn), nt,
             DUMMY_VAR__);
        current_statement__ = 142;
        stan::model::assign(sol,
          ode_sol(dt, nt, stan::math::append_row(x_init, z_init), SC, I1,
            tau0, K, x0, pstream__), "assigning variable sol");
        current_statement__ = 143;
        stan::model::assign(x,
          stan::model::rvalue(sol, "sol",
            stan::model::index_min_max(1, nn), stan::model::index_omni()),
          "assigning variable x");
        current_statement__ = 147;
        for (int i = 1; i <= nt; ++i) {
          current_statement__ = 144;
          stan::model::assign(xhat2_1,
            stan::math::to_row_vector(
              stan::math::add(
                stan::math::multiply(amp1,
                  stan::math::multiply(gain1,
                    stan::model::rvalue(x, "x",
                      stan::model::index_omni(), stan::model::index_uni(i)))),
                u1)),
            "assigning variable xhat2_1", stan::model::index_uni(i),
                                            stan::model::index_omni());
          current_statement__ = 145;
          stan::model::assign(xhat2_2,
            stan::math::to_row_vector(
              stan::math::add(
                stan::math::multiply(amp2,
                  stan::math::multiply(gain2,
                    stan::model::rvalue(x, "x",
                      stan::model::index_omni(), stan::model::index_uni(i)))),
                u2)),
            "assigning variable xhat2_2", stan::model::index_uni(i),
                                            stan::model::index_omni());
        }
        current_statement__ = 148;
        stan::model::assign(SEEG_bcor,
          correct_baseline(xhat2_1, nbs1, pstream__),
          "assigning variable SEEG_bcor");
        current_statement__ = 149;
        stan::model::assign(SEEG, stan::math::to_vector(SEEG_bcor),
          "assigning variable SEEG");
        current_statement__ = 150;
        stan::model::assign(EEG_bcor,
          correct_baseline(xhat2_2, nbs2, pstream__),
          "assigning variable EEG_bcor");
        current_statement__ = 151;
        stan::model::assign(EEG, stan::math::to_vector(EEG_bcor),
          "assigning variable EEG");
        current_statement__ = 154;
        for (int i = ((10 * ns1) + 1); i <= (nt * ns1); ++i) {
          current_statement__ = 152;
          lp_accum__.add(
            stan::math::normal_lpdf<false>(
              stan::model::rvalue(xs1, "xs1", stan::model::index_uni(i)),
              stan::model::rvalue(SEEG, "SEEG", stan::model::index_uni(i)),
              eps1));
        }
        current_statement__ = 157;
        for (int i = ((10 * ns2) + 1); i <= (nt * ns2); ++i) {
          current_statement__ = 155;
          lp_accum__.add(
            stan::math::normal_lpdf<false>(
              stan::model::rvalue(xs2, "xs2", stan::model::index_uni(i)),
              stan::model::rvalue(EEG, "EEG", stan::model::index_uni(i)),
              eps2));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> z_init_star =
         Eigen::Matrix<double, -1, 1>::Constant(nn,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      z_init_star = in__.template read<
                      Eigen::Matrix<local_scalar_t__, -1, 1>>(nn);
      Eigen::Matrix<double, -1, 1> x0_star =
         Eigen::Matrix<double, -1, 1>::Constant(nn,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      x0_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  nn);
      double K_star = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      K_star = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 -1.0, lp__);
      double amp1_star = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      amp1_star = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0.0, lp__);
      double amp2_star = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      amp2_star = in__.template read_constrain_lb<local_scalar_t__, 
                    jacobian__>(0.0, lp__);
      Eigen::Matrix<double, -1, 1> u1_star =
         Eigen::Matrix<double, -1, 1>::Constant(ns1,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      u1_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  ns1);
      Eigen::Matrix<double, -1, 1> u2_star =
         Eigen::Matrix<double, -1, 1>::Constant(ns2,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      u2_star = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                  ns2);
      double log_eps1_sq = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      log_eps1_sq = in__.template read<local_scalar_t__>();
      double log_eps2_sq = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      log_eps2_sq = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> x0 =
         Eigen::Matrix<double, -1, 1>::Constant(nn,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> z_init =
         Eigen::Matrix<double, -1, 1>::Constant(nn,
           std::numeric_limits<double>::quiet_NaN());
      double K = std::numeric_limits<double>::quiet_NaN();
      double amp = std::numeric_limits<double>::quiet_NaN();
      double amp1 = std::numeric_limits<double>::quiet_NaN();
      double amp2 = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double, -1, 1> u1 =
         Eigen::Matrix<double, -1, 1>::Constant(ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> u2 =
         Eigen::Matrix<double, -1, 1>::Constant(ns2,
           std::numeric_limits<double>::quiet_NaN());
      double eps1 = std::numeric_limits<double>::quiet_NaN();
      double eps2 = std::numeric_limits<double>::quiet_NaN();
      out__.write(z_init_star);
      out__.write(x0_star);
      out__.write(K_star);
      out__.write(amp1_star);
      out__.write(amp2_star);
      out__.write(u1_star);
      out__.write(u2_star);
      out__.write(log_eps1_sq);
      out__.write(log_eps2_sq);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 20;
      stan::model::assign(x0,
        stan::math::add(-3.0,
          stan::math::multiply(stan::math::multiply(0.30, eig1), x0_star)),
        "assigning variable x0");
      current_statement__ = 21;
      stan::model::assign(z_init,
        stan::math::add(4.1,
          stan::math::multiply(stan::math::multiply(0.1, eig1), z_init_star)),
        "assigning variable z_init");
      current_statement__ = 22;
      K = (Ks + (1.0 * K_star));
      current_statement__ = 23;
      amp1 = (0.005 + (0.01 * amp1_star));
      current_statement__ = 24;
      amp2 = (0.005 + (0.01 * amp2_star));
      current_statement__ = 25;
      stan::model::assign(u1,
        stan::math::add(2.0, stan::math::multiply(1.0, u1_star)),
        "assigning variable u1");
      current_statement__ = 26;
      stan::model::assign(u2,
        stan::math::add(2.0, stan::math::multiply(1.0, u2_star)),
        "assigning variable u2");
      current_statement__ = 27;
      eps1 = stan::math::exp(((0.33 * log_eps1_sq) - 3.0));
      current_statement__ = 28;
      eps2 = stan::math::exp(((0.33 * log_eps2_sq) - 3.0));
      if (emit_transformed_parameters__) {
        out__.write(x0);
        out__.write(z_init);
        out__.write(K);
        out__.write(amp);
        out__.write(amp1);
        out__.write(amp2);
        out__.write(u1);
        out__.write(u2);
        out__.write(eps1);
        out__.write(eps2);
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, -1> x =
         Eigen::Matrix<double, -1, -1>::Constant(nn, nt,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> z =
         Eigen::Matrix<double, -1, -1>::Constant(nn, nt,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_qqc2_1 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_q2_1 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_qqc2_2 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_q2_2 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> xhat_qqc_1 =
         Eigen::Matrix<double, -1, 1>::Constant(xhat_qqc_1_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> x_ppc_1 =
         Eigen::Matrix<double, -1, 1>::Constant(x_ppc_1_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> log_lik_1 =
         Eigen::Matrix<double, -1, 1>::Constant(log_lik_1_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_q_1 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> x_p_1 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> log_lik_sum =
         Eigen::Matrix<double, -1, 1>::Constant(nt,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 40;
      stan::model::assign(log_lik_sum, stan::math::rep_vector(0, nt),
        "assigning variable log_lik_sum");
      Eigen::Matrix<double, -1, 1> xhat_qqc_2 =
         Eigen::Matrix<double, -1, 1>::Constant(xhat_qqc_2_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> x_ppc_2 =
         Eigen::Matrix<double, -1, 1>::Constant(x_ppc_2_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> log_lik_2 =
         Eigen::Matrix<double, -1, 1>::Constant(log_lik_2_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> xhat_q_2 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> x_p_2 =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> SEEG_bcor =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns1,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> SEEG =
         Eigen::Matrix<double, -1, 1>::Constant(SEEG_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, -1> EEG_bcor =
         Eigen::Matrix<double, -1, -1>::Constant(nt, ns2,
           std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double, -1, 1> EEG =
         Eigen::Matrix<double, -1, 1>::Constant(EEG_1dim__,
           std::numeric_limits<double>::quiet_NaN());
      double gx = std::numeric_limits<double>::quiet_NaN();
      double dx = std::numeric_limits<double>::quiet_NaN();
      double dz = std::numeric_limits<double>::quiet_NaN();
      int num_params = std::numeric_limits<int>::min();
      int num_data = std::numeric_limits<int>::min();
      current_statement__ = 55;
      num_params = (((2 * (nt * (ns1 + ns2))) + nn) + 6);
      current_statement__ = 56;
      num_data = (nt * (ns1 + ns2));
      Eigen::Matrix<double, -1, -1> sol =
         Eigen::Matrix<double, -1, -1>::Constant(sol_1dim__, nt,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 57;
      stan::model::assign(sol,
        ode_sol(dt, nt, stan::math::append_row(x_init, z_init), SC, I1, tau0,
          K, x0, pstream__), "assigning variable sol");
      current_statement__ = 58;
      stan::model::assign(x,
        stan::model::rvalue(sol, "sol",
          stan::model::index_min_max(1, nn), stan::model::index_omni()),
        "assigning variable x");
      current_statement__ = 59;
      stan::model::assign(z,
        stan::model::rvalue(sol, "sol",
          stan::model::index_min((nn + 1)), stan::model::index_omni()),
        "assigning variable z");
      current_statement__ = 63;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 60;
        stan::model::assign(xhat_qqc2_1,
          stan::math::to_row_vector(
            stan::math::add(
              stan::math::multiply(amp1,
                stan::math::multiply(gain1,
                  stan::model::rvalue(x, "x",
                    stan::model::index_omni(), stan::model::index_uni(i)))),
              u1)),
          "assigning variable xhat_qqc2_1", stan::model::index_uni(i),
                                              stan::model::index_omni());
        current_statement__ = 61;
        stan::model::assign(xhat_qqc2_2,
          stan::math::to_row_vector(
            stan::math::add(
              stan::math::multiply(amp2,
                stan::math::multiply(gain2,
                  stan::model::rvalue(x, "x",
                    stan::model::index_omni(), stan::model::index_uni(i)))),
              u2)),
          "assigning variable xhat_qqc2_2", stan::model::index_uni(i),
                                              stan::model::index_omni());
      }
      current_statement__ = 64;
      stan::model::assign(xhat_qqc_1, stan::math::to_vector(xhat_qqc2_1),
        "assigning variable xhat_qqc_1");
      current_statement__ = 65;
      stan::model::assign(xhat_qqc_2, stan::math::to_vector(xhat_qqc2_2),
        "assigning variable xhat_qqc_2");
      current_statement__ = 66;
      stan::model::assign(SEEG_bcor,
        correct_baseline(xhat_qqc2_1, nbs1, pstream__),
        "assigning variable SEEG_bcor");
      current_statement__ = 67;
      stan::model::assign(SEEG, stan::math::to_vector(SEEG_bcor),
        "assigning variable SEEG");
      current_statement__ = 68;
      stan::model::assign(EEG_bcor,
        correct_baseline(xhat_qqc2_2, nbs2, pstream__),
        "assigning variable EEG_bcor");
      current_statement__ = 69;
      stan::model::assign(EEG, stan::math::to_vector(EEG_bcor),
        "assigning variable EEG");
      current_statement__ = 72;
      for (int i = 1; i <= (nt * ns1); ++i) {
        current_statement__ = 70;
        stan::model::assign(x_ppc_1,
          stan::math::normal_rng(
            stan::model::rvalue(xhat_qqc_1, "xhat_qqc_1",
              stan::model::index_uni(i)), eps1, base_rng__),
          "assigning variable x_ppc_1", stan::model::index_uni(i));
      }
      current_statement__ = 75;
      for (int i = 1; i <= (nt * ns1); ++i) {
        current_statement__ = 73;
        stan::model::assign(log_lik_1,
          stan::math::normal_lpdf<false>(
            stan::model::rvalue(xs1, "xs1", stan::model::index_uni(i)),
            stan::model::rvalue(xhat_qqc_1, "xhat_qqc_1",
              stan::model::index_uni(i)), eps1),
          "assigning variable log_lik_1", stan::model::index_uni(i));
      }
      current_statement__ = 78;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 76;
        stan::model::assign(xhat_q2_1,
          stan::math::to_row_vector(
            stan::math::add(
              stan::math::multiply(amp1,
                stan::math::multiply(gain1,
                  stan::model::rvalue(x, "x",
                    stan::model::index_omni(), stan::model::index_uni(i)))),
              u1)),
          "assigning variable xhat_q2_1", stan::model::index_uni(i),
                                            stan::model::index_omni());
      }
      current_statement__ = 82;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 80;
        for (int j = 1; j <= ns1; ++j) {
          current_statement__ = 79;
          stan::model::assign(x_p_1,
            stan::math::normal_rng(
              stan::model::rvalue(xhat_q2_1, "xhat_q2_1",
                stan::model::index_uni(i), stan::model::index_uni(j)), eps1,
              base_rng__),
            "assigning variable x_p_1", stan::model::index_uni(i),
                                          stan::model::index_uni(j));
        }
      }
      current_statement__ = 85;
      for (int i = 1; i <= (nt * ns2); ++i) {
        current_statement__ = 83;
        stan::model::assign(x_ppc_2,
          stan::math::normal_rng(
            stan::model::rvalue(xhat_qqc_2, "xhat_qqc_2",
              stan::model::index_uni(i)), eps2, base_rng__),
          "assigning variable x_ppc_2", stan::model::index_uni(i));
      }
      current_statement__ = 88;
      for (int i = 1; i <= (nt * ns2); ++i) {
        current_statement__ = 86;
        stan::model::assign(log_lik_2,
          stan::math::normal_lpdf<false>(
            stan::model::rvalue(xs2, "xs2", stan::model::index_uni(i)),
            stan::model::rvalue(xhat_qqc_2, "xhat_qqc_2",
              stan::model::index_uni(i)), eps2),
          "assigning variable log_lik_2", stan::model::index_uni(i));
      }
      current_statement__ = 91;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 89;
        stan::model::assign(xhat_q2_2,
          stan::math::to_row_vector(
            stan::math::add(
              stan::math::multiply(amp2,
                stan::math::multiply(gain2,
                  stan::model::rvalue(x, "x",
                    stan::model::index_omni(), stan::model::index_uni(i)))),
              u2)),
          "assigning variable xhat_q2_2", stan::model::index_uni(i),
                                            stan::model::index_omni());
      }
      current_statement__ = 95;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 93;
        for (int j = 1; j <= ns2; ++j) {
          current_statement__ = 92;
          stan::model::assign(x_p_2,
            stan::math::normal_rng(
              stan::model::rvalue(xhat_q2_2, "xhat_q2_2",
                stan::model::index_uni(i), stan::model::index_uni(j)), eps2,
              base_rng__),
            "assigning variable x_p_2", stan::model::index_uni(i),
                                          stan::model::index_uni(j));
        }
      }
      current_statement__ = 101;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 97;
        for (int j = 1; j <= ns1; ++j) {
          current_statement__ = 96;
          stan::model::assign(log_lik_sum,
            (stan::model::rvalue(log_lik_sum, "log_lik_sum",
               stan::model::index_uni(i)) +
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(Obs1, "Obs1",
                  stan::model::index_uni(i), stan::model::index_uni(j)),
                stan::model::rvalue(xhat_q2_1, "xhat_q2_1",
                  stan::model::index_uni(i), stan::model::index_uni(j)),
                eps1)),
            "assigning variable log_lik_sum", stan::model::index_uni(i));
        }
        current_statement__ = 99;
        for (int k = 1; k <= ns2; ++k) {
          current_statement__ = 98;
          stan::model::assign(log_lik_sum,
            (stan::model::rvalue(log_lik_sum, "log_lik_sum",
               stan::model::index_uni(i)) +
              stan::math::normal_lpdf<false>(
                stan::model::rvalue(Obs2, "Obs2",
                  stan::model::index_uni(i), stan::model::index_uni(k)),
                stan::model::rvalue(xhat_q2_2, "xhat_q2_2",
                  stan::model::index_uni(i), stan::model::index_uni(k)),
                eps1)),
            "assigning variable log_lik_sum", stan::model::index_uni(i));
        }
      }
      out__.write(x);
      out__.write(z);
      out__.write(xhat_qqc2_1);
      out__.write(xhat_q2_1);
      out__.write(xhat_qqc2_2);
      out__.write(xhat_q2_2);
      out__.write(xhat_qqc_1);
      out__.write(x_ppc_1);
      out__.write(log_lik_1);
      out__.write(xhat_q_1);
      out__.write(x_p_1);
      out__.write(log_lik_sum);
      out__.write(xhat_qqc_2);
      out__.write(x_ppc_2);
      out__.write(log_lik_2);
      out__.write(xhat_q_2);
      out__.write(x_p_2);
      out__.write(SEEG_bcor);
      out__.write(SEEG);
      out__.write(EEG_bcor);
      out__.write(EEG);
      out__.write(gx);
      out__.write(dx);
      out__.write(dz);
      out__.write(num_params);
      out__.write(num_data);
      out__.write(sol);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__, -1, 1> z_init_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        stan::model::assign(z_init_star, in__.read<local_scalar_t__>(),
          "assigning variable z_init_star", stan::model::index_uni(sym1__));
      }
      out__.write(z_init_star);
      Eigen::Matrix<local_scalar_t__, -1, 1> x0_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(nn, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        stan::model::assign(x0_star, in__.read<local_scalar_t__>(),
          "assigning variable x0_star", stan::model::index_uni(sym1__));
      }
      out__.write(x0_star);
      local_scalar_t__ K_star = DUMMY_VAR__;
      K_star = in__.read<local_scalar_t__>();
      out__.write_free_lb(-1.0, K_star);
      local_scalar_t__ amp1_star = DUMMY_VAR__;
      amp1_star = in__.read<local_scalar_t__>();
      out__.write_free_lb(0.0, amp1_star);
      local_scalar_t__ amp2_star = DUMMY_VAR__;
      amp2_star = in__.read<local_scalar_t__>();
      out__.write_free_lb(0.0, amp2_star);
      Eigen::Matrix<local_scalar_t__, -1, 1> u1_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns1, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        stan::model::assign(u1_star, in__.read<local_scalar_t__>(),
          "assigning variable u1_star", stan::model::index_uni(sym1__));
      }
      out__.write(u1_star);
      Eigen::Matrix<local_scalar_t__, -1, 1> u2_star =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(ns2, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        stan::model::assign(u2_star, in__.read<local_scalar_t__>(),
          "assigning variable u2_star", stan::model::index_uni(sym1__));
      }
      out__.write(u2_star);
      local_scalar_t__ log_eps1_sq = DUMMY_VAR__;
      log_eps1_sq = in__.read<local_scalar_t__>();
      out__.write(log_eps1_sq);
      local_scalar_t__ log_eps2_sq = DUMMY_VAR__;
      log_eps2_sq = in__.read<local_scalar_t__>();
      out__.write(log_eps2_sq);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"z_init_star", "x0_star", "K_star",
      "amp1_star", "amp2_star", "u1_star", "u2_star", "log_eps1_sq",
      "log_eps2_sq", "x0", "z_init", "K", "amp", "amp1", "amp2", "u1", "u2",
      "eps1", "eps2", "x", "z", "xhat_qqc2_1", "xhat_q2_1", "xhat_qqc2_2",
      "xhat_q2_2", "xhat_qqc_1", "x_ppc_1", "log_lik_1", "xhat_q_1", "x_p_1",
      "log_lik_sum", "xhat_qqc_2", "x_ppc_2", "log_lik_2", "xhat_q_2",
      "x_p_2", "SEEG_bcor", "SEEG", "EEG_bcor", "EEG", "gx", "dx", "dz",
      "num_params", "num_data", "sol"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(nn)
                                                                   },
      std::vector<size_t>{static_cast<size_t>(nn)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(ns2)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(nn)},
      std::vector<size_t>{static_cast<size_t>(nn)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(ns2)}, std::vector<size_t>{
      }, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(nn), static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(nn), static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns2)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns2)},
      std::vector<size_t>{static_cast<size_t>(xhat_qqc_1_1dim__)},
      std::vector<size_t>{static_cast<size_t>(x_ppc_1_1dim__)},
      std::vector<size_t>{static_cast<size_t>(log_lik_1_1dim__)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(nt)},
      std::vector<size_t>{static_cast<size_t>(xhat_qqc_2_1dim__)},
      std::vector<size_t>{static_cast<size_t>(x_ppc_2_1dim__)},
      std::vector<size_t>{static_cast<size_t>(log_lik_2_1dim__)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns2)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns2)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns1)},
      std::vector<size_t>{static_cast<size_t>(SEEG_1dim__)},
      std::vector<size_t>{static_cast<size_t>(nt), static_cast<size_t>(ns2)},
      std::vector<size_t>{static_cast<size_t>(EEG_1dim__)},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{},
      std::vector<size_t>{static_cast<size_t>(sol_1dim__),
                          static_cast<size_t>(nt)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "z_init_star" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x0_star" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "K_star");
    param_names__.emplace_back(std::string() + "amp1_star");
    param_names__.emplace_back(std::string() + "amp2_star");
    for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "u1_star" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "u2_star" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "log_eps1_sq");
    param_names__.emplace_back(std::string() + "log_eps2_sq");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x0" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z_init" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "K");
      param_names__.emplace_back(std::string() + "amp");
      param_names__.emplace_back(std::string() + "amp1");
      param_names__.emplace_back(std::string() + "amp2");
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "u1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "u2" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "eps1");
      param_names__.emplace_back(std::string() + "eps2");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_qqc2_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q2_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_qqc2_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q2_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= xhat_qqc_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "xhat_qqc_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= x_ppc_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x_ppc_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= log_lik_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_p_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_sum" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= xhat_qqc_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "xhat_qqc_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= x_ppc_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x_ppc_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= log_lik_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_p_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "SEEG_bcor" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= SEEG_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "SEEG" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "EEG_bcor" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= EEG_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "EEG" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "gx");
      param_names__.emplace_back(std::string() + "dx");
      param_names__.emplace_back(std::string() + "dz");
      param_names__.emplace_back(std::string() + "num_params");
      param_names__.emplace_back(std::string() + "num_data");
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= sol_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sol" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "z_init_star" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x0_star" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "K_star");
    param_names__.emplace_back(std::string() + "amp1_star");
    param_names__.emplace_back(std::string() + "amp2_star");
    for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "u1_star" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "u2_star" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "log_eps1_sq");
    param_names__.emplace_back(std::string() + "log_eps2_sq");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x0" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= nn; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "z_init" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "K");
      param_names__.emplace_back(std::string() + "amp");
      param_names__.emplace_back(std::string() + "amp1");
      param_names__.emplace_back(std::string() + "amp2");
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "u1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "u2" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "eps1");
      param_names__.emplace_back(std::string() + "eps2");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nn; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "z" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_qqc2_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q2_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_qqc2_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q2_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= xhat_qqc_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "xhat_qqc_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= x_ppc_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x_ppc_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= log_lik_1_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_1" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_p_1" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_sum" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= xhat_qqc_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "xhat_qqc_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= x_ppc_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "x_ppc_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= log_lik_2_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_2" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xhat_q_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_p_2" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns1; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "SEEG_bcor" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= SEEG_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "SEEG" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= ns2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "EEG_bcor" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= EEG_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "EEG" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "gx");
      param_names__.emplace_back(std::string() + "dx");
      param_names__.emplace_back(std::string() + "dz");
      param_names__.emplace_back(std::string() + "num_params");
      param_names__.emplace_back(std::string() + "num_data");
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= sol_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sol" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"z_init_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"parameters\"},{\"name\":\"x0_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"parameters\"},{\"name\":\"K_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"amp1_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"amp2_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"u1_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns1) + "},\"block\":\"parameters\"},{\"name\":\"u2_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns2) + "},\"block\":\"parameters\"},{\"name\":\"log_eps1_sq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_eps2_sq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x0\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"transformed_parameters\"},{\"name\":\"z_init\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"u1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"u2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"eps2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nn) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nn) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc2_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q2_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc2_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q2_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(xhat_qqc_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_ppc_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(x_ppc_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_lik_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_p_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_sum\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(xhat_qqc_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_ppc_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(x_ppc_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_lik_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_p_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"SEEG_bcor\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"SEEG\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(SEEG_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"EEG_bcor\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"EEG\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(EEG_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"gx\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"dx\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"dz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"num_params\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"num_data\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"sol\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(sol_1dim__) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"z_init_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"parameters\"},{\"name\":\"x0_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"parameters\"},{\"name\":\"K_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"amp1_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"amp2_star\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"u1_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns1) + "},\"block\":\"parameters\"},{\"name\":\"u2_star\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns2) + "},\"block\":\"parameters\"},{\"name\":\"log_eps1_sq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_eps2_sq\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x0\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"transformed_parameters\"},{\"name\":\"z_init\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nn) + "},\"block\":\"transformed_parameters\"},{\"name\":\"K\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"amp2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"u1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns1) + "},\"block\":\"transformed_parameters\"},{\"name\":\"u2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(ns2) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"eps2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nn) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nn) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc2_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q2_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc2_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q2_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(xhat_qqc_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_ppc_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(x_ppc_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_1\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_lik_1_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_p_1\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_sum\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_qqc_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(xhat_qqc_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_ppc_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(x_ppc_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_2\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_lik_2_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"xhat_q_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"x_p_2\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"SEEG_bcor\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns1) + "},\"block\":\"generated_quantities\"},{\"name\":\"SEEG\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(SEEG_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"EEG_bcor\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(nt) + ",\"cols\":" + std::to_string(ns2) + "},\"block\":\"generated_quantities\"},{\"name\":\"EEG\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(EEG_1dim__) + "},\"block\":\"generated_quantities\"},{\"name\":\"gx\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"dx\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"dz\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"num_params\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"num_data\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"sol\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(sol_1dim__) + ",\"cols\":" + std::to_string(nt) + "},\"block\":\"generated_quantities\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((nn + nn) + 1) + 1) + 1) + ns1) + ns2) + 1) + 1);
      const size_t num_transformed = 
  (((((((((nn + nn) + 1) + 1) + 1) + 1) + ns1) + ns2) + 1) + 1);
      const size_t num_gen_quantities = 
  (((((((((((((((((((((((((((nn * nt) + (nn * nt)) + (nt * ns1)) +
                           (nt * ns1)) + (nt * ns2)) + (nt * ns2)) +
                        xhat_qqc_1_1dim__) + x_ppc_1_1dim__) +
                      log_lik_1_1dim__) + (nt * ns1)) + (nt * ns1)) + nt) +
                  xhat_qqc_2_1dim__) + x_ppc_2_1dim__) + log_lik_2_1dim__) +
               (nt * ns2)) + (nt * ns2)) + (nt * ns1)) + SEEG_1dim__) +
           (nt * ns2)) + EEG_1dim__) + 1) + 1) + 1) + 1) + 1) +
    (sol_1dim__ * nt));
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((nn + nn) + 1) + 1) + 1) + ns1) + ns2) + 1) + 1);
      const size_t num_transformed = 
  (((((((((nn + nn) + 1) + 1) + 1) + 1) + ns1) + ns2) + 1) + 1);
      const size_t num_gen_quantities = 
  (((((((((((((((((((((((((((nn * nt) + (nn * nt)) + (nt * ns1)) +
                           (nt * ns1)) + (nt * ns2)) + (nt * ns2)) +
                        xhat_qqc_1_1dim__) + x_ppc_1_1dim__) +
                      log_lik_1_1dim__) + (nt * ns1)) + (nt * ns1)) + nt) +
                  xhat_qqc_2_1dim__) + x_ppc_2_1dim__) + log_lik_2_1dim__) +
               (nt * ns2)) + (nt * ns2)) + (nt * ns1)) + SEEG_1dim__) +
           (nt * ns2)) + EEG_1dim__) + 1) + 1) + 1) + 1) + 1) +
    (sol_1dim__ * nt));
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 9> names__{"z_init_star", "x0_star",
      "K_star", "amp1_star", "amp2_star", "u1_star", "u2_star",
      "log_eps1_sq", "log_eps2_sq"};
      const std::array<Eigen::Index, 9> constrain_param_sizes__{nn, nn, 
       1, 1, 1, ns1, ns2, 1, 1};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } 
using stan_model = vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace::vep_sample_euler_bcorr_fast_both_EEG_SEEG_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return vep_sample_euler_bcorr_fast_both_EEG_SEEG_model_namespace::profiles__;
}

#endif


